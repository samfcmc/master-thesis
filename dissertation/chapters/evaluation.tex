%!TEX root = ../dissertation.tex

\chapter{Evaluation}
\label{chapter:evaluation}
% Introduce evaluation...
% Main goals
% Setup used

After the implementation of this solution some experiments were performed in order to test it.
When the mobile app for end users scans for beacons, it tries to find the nearest one that belongs to one or more Smart Places and notifify the user if at least one was found.
If the user touches one of those notifications, the interface to the selected Smart Place is shown and the user can start to interact with it.
Then, the app will keep on scanning for the nearest beacon and request the data, associated to that beacon in the context of the given Smart Place.
This means that somehow, it has into account the physical distance between the device and the beacons.
The library used to handle the beacons has a method to get the distance from a given beacon.
There is a need to check if the distance's value we get from this library is reliable.
The same app needs to run in background in order to let the user be notified when he/she is nearby any Smart Place, instead of requiring his/her interaction.
However, as any service running in background, it can have a negative impact on the mobile device's resources usage such as battery.
A set of experiments was performed to evaluate the overhead introduced by our solution and if it is acceptable, having an app, running in background, scanning for beacons.

In section \ref{sec:evaluation_setup}, we describe the setup used, such as the mobile device and the set of beacons.
Then, we present two sets of experiments.
The first one, presented in section \ref{sec:evaluation_nearest_beacon}, was performed in order to get a good insight about the reliability of the distance value we get from the beacons library \gls{API}, to see if Smart Places that rely on the nearest beacon would work as expected.
The other set of experiments, introduced in section \ref{sec:evaluation_energy_consumption}, measured data transferred (sent and received) and power drain, to take conclusions about if the energy consumption overhead introduced by our solution would be acceptable in a daily basis usage and the relation between the data transferred, due to requests to the backend, and the battery consumption.
For each set of experiments, we present the methodology such as the conditions and measures taken and the results.
Finnaly, section \ref{sec:evaluation_summary} summarizes this chapter.

\section{Setup}
\label{sec:evaluation_setup}
In the evaluation process, a smartphone and a set of three beacons were used.
The smartphone was a \tm{Motorola}
Moto G\footnote{http://www.gsmarena.com/motorola\_moto\_g-5831.php}.
This device has the following specifications:
\begin{description}
  \item[\gls{CPU}:] Quad-core 1.2 GHz Cortex-A7\footnote{http://www.arm.com/products/processors/cortex-a/cortex-a7.php}
  \item[\gls{GPU}:] Adreno 305
  \item[\gls{RAM}:] 1 \gls{GB}
  \item[Internal storage:]: 16 \gls{GB}
  \item[Screen:] 4.5 inches
  \item[Battery:] Non-removable Li-Ion 2070 \gls{mAh} battery
  \item[\gls{OS}:] Android 5.0.2 (Lollipop\footnote{https://www.android.com/versions/lollipop-5-0})
\end{description}

\section{Nearest Beacon Detection}
\label{sec:evaluation_nearest_beacon}
Our solution relies on a library, which its \gls{API} allows us to get the distance from a given beacon.
However, this value is related to the signal's strength that comes from the beacon.
We performed a set of experiments to verify how reliable was this value and if we can use that value to compute which beacon is the nearest one.
Next, related to this set of experiments, we describe the methodology used and summarize the results.

\subsection{Methodology}
\label{sub:evaluation_nearest_beacon_methodology}
The set of experiments, summarized in Table~\ref{tab:experiments_nearest_beacon}, try to test if the mobile app can detect the nearest beacon.
In these experiments, the Smart Musem example was used.
In each experiment it ran for 5 minutes using 10 seconds as the interval between each scan.
10 seconds was chosen because it is a reasonable value to walk in the museum to have enough time to perform any computation that was needed after each scan.
In each scan, the app executes code that checks if the scanned beacons were already detected in a previous scan. If they were not, the data associated to those beacons is requested from the backend which, depending on the internet connection, can take some time.
This time interval between each scan seemed reasonable to make the request and compute the result until a new scan occurs.
With a much lower value, we could have a situation where another scan occurs while the previous one was not computed yet.
Running the experiment for 5 minutes, with the mentioned interval between each scan, allowed us to have more than 20 scans.
Then, in Android Studio log output, it was possible to check how many times each beacon was detected as the nearest one.

The smartphone and the three beacons were disposed in a layout, where each beacon was equally distant from each other and the smartphone was close to one of them, as shown in Figure~\ref{fig:layout_experiments_nearest_beacon} where value \emph{d} is the distance between beacons.
The names below each beacon (ice, blueberry and mint), were defined by \tm{Estimote} in
the developer pack.
In this first set of experiments, the value d starts at 50 centimeters and is increased by 50 centimeters in each experiment until the 4th one where it is 2 meters.

\includeTable{experiments_nearest_beacon}

\begin{figure}[!ht]
  \centering
    \includegraphics[width=0.5\textwidth, keepaspectratio]{images/nearest_beacon}
    \caption[Layout for experiments of nearest beacon]{Layout used for the experiments to get the accuracy of the distance value}
    \label{fig:layout_experiments_nearest_beacon}
\end{figure}

\subsection{Results}
\label{sub:evaluation_nearest_beacon_results}
The mobile app for end users scans for beacons but only requests data for the nearest one. To get the nearest one, it has to rely on the signal strength to calculate the distance. We performed 4 experiments in order to try to get the accuracy of the mechanism that calculates the distance that the mobile device is from a given beacon.
The results of these experiments are summarized in Table~\ref{tab:results_nearest_beacon} where it is possible to see for each beacon how many times it was detected as the nearest one.

Taking into account the layout that was used (see Figure~\ref{fig:layout_experiments_nearest_beacon}), the nearest beacon was the one with name ``ice'' (the blue one).
From Table~\ref{tab:results_nearest_beacon} it was possible to create the graphic shown in Figure~\ref{fig:results_experiments_nearest_beacon} which shows that, as we increase the distance between beacons, the accuracy to detect the nearest beacon also increases.
In all experiments, this beacon was detected as the nearest one at least 50\% off all scans performed.
The only difference between all experiments is the distance between beacons.
We can conclude that, it is recommended that the beacons are at least, 1.5m or 2m distant from each other.

\includeTable{results_nearest_beacon}

\begin{figure}[!ht]
  \centering
    \includegraphics[width=0.5\textwidth, keepaspectratio]{images/results_nearest_beacon}
    \caption[Distance between beacons vs Accuracy]{Relation between distance between beacons and accuracy to detect the nearest beacon}
    \label{fig:results_experiments_nearest_beacon}
\end{figure}

In an environment where the beacons are close to each other, our solution might not work as expected.
For instance, in the previously described Smart Restaurant example
the tables should not be close to each other. This is not always possible because some restaurants try to optimize space and have tables as much close to each other as possible.
In the Smart Museum example two objects in a given exhibition should not be close to each other.
Otherwise, the visitor would be notified about an object and he might be looking at another one.
This error can be avoided using solutions such as Estimote Indoor \gls{SDK}\footnote{http://github.com/Estimote/iOS-Indoor-SDK} that can be used to obtain the physical indoors positon of the user.
However, it is only available for iOS.

\section{Energy Consumption}
\label{sec:evaluation_energy_consumption}
Another important aspect of this solution is the battery consumption.
Since our mobile app for end users runs on background to scan for nearby beacons, that can have a negative impact on the device's battery. If the user notices that the battery drains too fast, he/she will not use this solution.
Similar to section \ref{sec:evaluation_nearest_beacon} in the next sub sections we describe the metholodogy used and explain the results obtained in these experiments.

\subsection{Methodology}
\label{sub:evaluation_energy_consumption_methodology}
Table~\ref{tab:experiments_battery} outlines the experiments performed to evaluate the battery consumption.
Figure~\ref{fig:layout_experiments_battery_consumption} shows the layout used for this group of experiments.
We have used the same beacons as in the experiments described in section \ref{sec:evaluation_nearest_beacon}.
The beacons are equally distant, 25 cm, from each other.
The smartphone is at the same distance from the beacon in the middle, the green one named mint.
We performed six experiments.
In each one the app was turned on and ran for 1 hour in background mode scanning for beacons in order to discover nearby Smart Places.
The first two used \gls{WiFi} data connection.
The remaining used \gls{3G} mobile network.
Different data connection means can lead to different energy consumptions.
We need to understand which connection, \gls{WiFi} or \gls{3G}, drains more power.
If it is \gls{3G}, the user might only use our solution if he/she is connected to a \gls{WiFi} \gls{AP}.
We want our mobile app to be always turned on scanning for nearby Smart Places.
Using it only when \gls{WiFi} is available would make its usage very limited and the user would not take the full advantage of it because he/she needs be aware that a \gls{WiFi} \gls{AP} is available and turn the mobile app on again.
We tested two values for the interval between each scan, 5 minutes because it is the default value that the beacons library use in background mode, and 2 and half minutes.
The second value is half the first in order to see how much more power is drained when we set a smaller value for the interval between each scan.
Trying to find a smaller interval is important because it will reduce the probability that the user was not able to discover a nearby Smart Place.

The following scenarios were tested:
\begin{itemize}
  \item
  When the user stays in the same Smart Place the entire experiment;
  % Explain better
  \item
  When the user moves from one Smart Place to another, at each two and half minutes.
  % Explain better
\end{itemize}

\includeTable{experiments_battery}

\begin{figure}[!ht]
  \centering
    \includegraphics[width=0.5\textwidth, keepaspectratio]{images/experiments_battery_layout}
    \caption[Layout for experiments of battery consumption]{Layout used for the experiments to get the battery consumption}
    \label{fig:layout_experiments_battery_consumption}
\end{figure}

The mobile app for end users has a cache that stores the beacons that were already scanned.
This way, repeated communications with the backend are avoided.
Data communications, \gls{WiFi} or \gls{3G}, are the major source of battery drain as suggested in studies such as \cite{energy}.
To test both scenarios we would need more than three beacons spread along a big space.
Instead, we simulated the user walking passing by multiple Smart Places just by cleaning the cache, at each scan process.
This forced the app to make requests to the backend each time the three beacons were detected, allowing us to understand the impact of these requests on the power drain.
We used Battery Historian\footnote{https://developer.android.com/tools/performance/batterystats-battery-historian/index.html} to measure the power drain and how much data was transferred (sent and received). This tool allows developers to get the percentage of power drain of any application.

\subsection{Results}
\label{sub:evaluation_energy_consumption_results}
As any service running in background it can imply some overhead in terms of energy.
Following the methodology, explained before, we evaluated the battery consumption.
For the first scenario, when the user stays in the same Smart Place, during each experiment, the results are summarized in Table~\ref{tab:results_battery_stopped} where we can see, for each variation of data connection type (\gls{WiFi} and \gls{3G}) and interval between each scan, the values obtained for power drain and data transferred.
From this table it was possible to create the graphic shown in Figure~\ref{fig:results_battery_stopped}.
The battery consumption using \gls{WiFi} is almost zero.
However, when using \gls{3G}, the battery consumption raises more than 30 times than using \gls{WiFi}.

\includeTable{results_battery_stopped}

\begin{figure}[!ht]
  \centering
    \includegraphics[width=0.8\textwidth, keepaspectratio]{images/results_battery_stopped}
    \caption[Power drain when the user does not move]{Relation between power drain and interval between each scan in the scenario where the user stays in the same Smart Place}
    \label{fig:results_battery_stopped}
\end{figure}

From this results, it is possible to conclude that, our solution introduces the most overhead when using \gls{3G} as the mean to perform data communications such as, requests to the backend.
For each data connection type (\gls{WiFi} and \gls{3G}), we tested two values for the interval between each scan for nearby beacons.
We can observe that, when we decrease the interval between each scan in half, the battery consumption increases in 0.1\%.
Taking into account that we spent one hour in each experiment and assuming that the values for the power drain grow lineary, it is possible to say that, for two and half and five minutes in interval between each scan, we would have 6.96\% and 9.6\%, in 24 hours, of power drain, respectively.
The values are still low but they can demotivate the usage of our solution because, it is very likely that the users already have mobile apps, that use mobile data, already installed in their devices.

Since the power drain is higher when using \gls{3G}, we tested two of the most popular apps using this data connection type, Facebook\footnote{http://play.google.com/store/apps/details?id=com.facebook.katana} and Facebook Messenger\footnote{http://play.google.com/store/apps/details?id=com.facebook.orca} that also have services running in background and need to perform requests using an Internet connection.
Table~\ref{tab:results_facebook} summarizes these tests.
Each test ran in 1 hour.
While running Facebook, we used it to check our news feed in 5 minutes. The rest of the time the app was running in background.
With Facebook Messenger, we received three messages during the experiment.
It is possible to say that most of the power drain was due to background activities.
We will use these values as a reference to compare with the power drain in the second scenario, that is, at each scan the user moves from one place to another which implies more requests to the backend.

\includeTable{results_facebook}

Regarding the second scenario, where the user moves from one Smart Place to another, at each two and half minutes.
Table~\ref{tab:results_battery_walking}, shows the results for this scenario. Here, we got more power drain than in the previous scenario.
These results shows that, the more communication with the backend is required, more power our solution drains.
Once more, using \gls{WiFi}, we have got almost zero power drain.
However, similar to the results in the previous scenario, there is more power drain using \gls{3G}.
Graphic shown in Figure~\ref{fig:results_battery_walking} shows that, using two minutes and half of interval between each scan, we got more 0.71\% than using five minutes.
As happened before, there is more power drain when we increase the interval between each scan.
% Relate with Facebook and Messenger apps
In the worst case we obtained a power drain of 2.71\% which is approximately 71\% less than using Facebook in the same period of time and more than 65\% of using Facebook Messenger.
Using these two apps as a reference in terms of apps that run services in background, we can say that the battery consumption is acceptable for a daily basis usage.
However, this is an aspect that needs to be improved.

\includeTable{results_battery_walking}

\begin{figure}[!ht]
  \centering
    \includegraphics[width=0.8\textwidth, keepaspectratio]{images/results_battery_walking}
    \caption[Power drain when the user is moving]{Relation between power drain and interval between each scan in the scenario where the user moves along multiple Smart Places}
    \label{fig:results_battery_walking}
\end{figure}

\section{Summary}
\label{sec:evaluation_summary}
% Setup
% -> Smartphone and 3 beacons of Estimote
% Two kinds of experiments
After developing the Smart Places solution, we performed an evaluation.
We have used a \tm{Motorola} Moto G smartphone and three beacons from \tm{Estimote} and we performed two sets of experiments.

% Nearest beacon
% -> What and why
% -> Comment results
The mobile app for end users scans for nearby beacons and requests information, to the backend, about the one that is less distant to the mobile device.
Somehow, the app needs to be able to get the distance from a given beacon.
Our mobile apps project used a library to handle the \gls{BLE} beacons. This library has a method to get the distance, from a given beacon, that was previously scanned.
However, we performed experiments in order to see if it is possible to trust this value.
Our experiments showed that, to build applications that rely on detecting the nearest beacon, the beacons need to be, at least, 1.5m distant from each other.
As we raise the distance between beacons, the nearest beacon is successfully detected.

% Energy consumption
% -> What and why
% -> Comment results
The mobile app for end users scans for nearby beacons in background.
As any service running in background, it can introduce an overhead in terms of energy consumption.
We performed a set of experiments to get the power drain and data transferred (sent and received) by the mobile app.
To get the power drain and data transferred values we used Battery Historian tool.
We have tested two different scenarios. A scenario where the user stays in the same Smart Place and another one where he is always moving from one Smart Place to another.
Each experiment runned for one hour.
For each scenario, we tested \gls{WiFi} and \gls{3G} as data connection means.
The results showed that the power drain is bigger when using \gls{3G}. When using \gls{WiFi}, the power drain is almost zero.
In the scenario where the user does not move, the power drain is less than 1\%.
However, in the scenario where the user is always moving, which implies more requests to the backend, because new Smart Places are detected in each new scan, the power drain can be more than 2\%.
% Compare with Facebook and Facebook Messenger
We have measured the power drain of two popular apps, Facebook and Facebook Messenger, because these apps also have services running in background.
The power drain of these apps was used as a reference in order to compare with our solution in the worst case, when it needs to make requests to the backend in each scan.
Comparing the worst power drain in our solution with the two mentioned apps, we can say that the battery consumption of our solution is acceptable but needs to be improved.
